#pragma once

#include <string_view>
#include <list>
#include <fmt/format.h>

enum class lex {
    whitespace,
    single_comment,
    multi_comment,
    identifier,
    full_stop,
    slash,
    semicolon,
    variable,
    equals,
    open_bracket,
    close_bracket,
    number,
    minus,
    plus,
    asterisk,
    ampersand,
    percent,
    pipe,
    string_literal,
    binary_literal,
    money_literal,
    comma,
    greater_than,
    less_than,
    colon,
    exclamation_point,
    open_brace,
    close_brace,
    ADD,
    ALL,
    ALTER,
    AND,
    ANY,
    AS,
    ASC,
    AUTHORIZATION,
    BACKUP,
    BEGIN,
    BETWEEN,
    BREAK,
    BROWSE,
    BULK,
    BY,
    CASCADE,
    CASE,
    CHECK,
    CHECKPOINT,
    CLOSE,
    CLUSTERED,
    COALESCE,
    COLLATE,
    COLUMN,
    COMMIT,
    COMPUTE,
    CONSTRAINT,
    CONTAINS,
    CONTAINSTABLE,
    CONTINUE,
    CONVERT,
    CREATE,
    CROSS,
    CURRENT,
    CURRENT_DATE,
    CURRENT_TIME,
    CURRENT_TIMESTAMP,
    CURRENT_USER,
    CURSOR,
    DATABASE,
    DBCC,
    DEALLOCATE,
    DECLARE,
    DEFAULT,
    SQL_DELETE,
    DENY,
    DESC,
    DISTINCT,
    DISTRIBUTED,
    DOUBLE,
    DROP,
    ELSE,
    END,
    ERRLVL,
    ESCAPE,
    EXCEPT,
    EXEC,
    EXISTS,
    EXIT,
    EXTERNAL,
    FETCH,
    FILE,
    FILLFACTOR,
    FOR,
    FOREIGN,
    FREETEXT,
    FREETEXTTABLE,
    FROM,
    FULL,
    FUNCTION,
    GOTO,
    GRANT,
    GROUP,
    HAVING,
    HOLDLOCK,
    IDENTITY,
    IDENTITY_INSERT,
    IDENTITYCOL,
    IF,
    SQL_IN,
    INDEX,
    INNER,
    INSERT,
    INTERSECT,
    INTO,
    IS,
    JOIN,
    KEY,
    KILL,
    LEFT,
    LIKE,
    LINENO,
    MERGE,
    NATIONAL,
    NOCHECK,
    NONCLUSTERED,
    NOT,
    SQL_NULL,
    NULLIF,
    OF,
    OFF,
    OFFSETS,
    ON,
    OPEN,
    OPENDATASOURCE,
    OPENQUERY,
    OPENROWSET,
    OPENXML,
    OPTION,
    OR,
    ORDER,
    OUTER,
    OVER,
    PERCENT,
    PIVOT,
    PLAN,
    PRIMARY,
    PRINT,
    PROCEDURE,
    PUBLIC,
    RAISERROR,
    READ,
    READTEXT,
    RECONFIGURE,
    REFERENCES,
    REPLICATION,
    RESTORE,
    RESTRICT,
    RETURN,
    REVERT,
    REVOKE,
    RIGHT,
    ROLLBACK,
    ROWCOUNT,
    ROWGUIDCOL,
    RULE,
    SAVE,
    SCHEMA,
    SELECT,
    SEMANTICKEYPHRASETABLE,
    SEMANTICSIMILARITYDETAILSTABLE,
    SEMANTICSIMILARITYTABLE,
    SESSION_USER,
    SET,
    SETUSER,
    SHUTDOWN,
    SOME,
    STATISTICS,
    SYSTEM_USER,
    TABLE,
    TABLESAMPLE,
    TEXTSIZE,
    THEN,
    TO,
    TOP,
    TRAN,
    TRANSACTION,
    TRIGGER,
    TRUNCATE,
    TRY_CONVERT,
    TSEQUAL,
    UNION,
    UNIQUE,
    UNPIVOT,
    UPDATE,
    UPDATETEXT,
    USE,
    USER,
    VALUES,
    VARYING,
    VIEW,
    WAITFOR,
    WHEN,
    WHERE,
    WHILE,
    WITH,
    WRITETEXT,
};

static const struct {
    std::string_view s;
    enum lex type;
} reserved_words[] = {
    { "ADD", lex::ADD },
    { "ALL", lex::ALL },
    { "ALTER", lex::ALTER },
    { "AND", lex::AND },
    { "ANY", lex::ANY },
    { "AS", lex::AS },
    { "ASC", lex::ASC },
    { "AUTHORIZATION", lex::AUTHORIZATION },
    { "BACKUP", lex::BACKUP },
    { "BEGIN", lex::BEGIN },
    { "BETWEEN", lex::BETWEEN },
    { "BREAK", lex::BREAK },
    { "BROWSE", lex::BROWSE },
    { "BULK", lex::BULK },
    { "BY", lex::BY },
    { "CASCADE", lex::CASCADE },
    { "CASE", lex::CASE },
    { "CHECK", lex::CHECK },
    { "CHECKPOINT", lex::CHECKPOINT },
    { "CLOSE", lex::CLOSE },
    { "CLUSTERED", lex::CLUSTERED },
    { "COALESCE", lex::COALESCE },
    { "COLLATE", lex::COLLATE },
    { "COLUMN", lex::COLUMN },
    { "COMMIT", lex::COMMIT },
    { "COMPUTE", lex::COMPUTE },
    { "CONSTRAINT", lex::CONSTRAINT },
    { "CONTAINS", lex::CONTAINS },
    { "CONTAINSTABLE", lex::CONTAINSTABLE },
    { "CONTINUE", lex::CONTINUE },
    { "CONVERT", lex::CONVERT },
    { "CREATE", lex::CREATE },
    { "CROSS", lex::CROSS },
    { "CURRENT", lex::CURRENT },
    { "CURRENT_DATE", lex::CURRENT_DATE },
    { "CURRENT_TIME", lex::CURRENT_TIME },
    { "CURRENT_TIMESTAMP", lex::CURRENT_TIMESTAMP },
    { "CURRENT_USER", lex::CURRENT_USER },
    { "CURSOR", lex::CURSOR },
    { "DATABASE", lex::DATABASE },
    { "DBCC", lex::DBCC },
    { "DEALLOCATE", lex::DEALLOCATE },
    { "DECLARE", lex::DECLARE },
    { "DEFAULT", lex::DEFAULT },
    { "DELETE", lex::SQL_DELETE },
    { "DENY", lex::DENY },
    { "DESC", lex::DESC },
    { "DISTINCT", lex::DISTINCT },
    { "DISTRIBUTED", lex::DISTRIBUTED },
    { "DOUBLE", lex::DOUBLE },
    { "DROP", lex::DROP },
    { "ELSE", lex::ELSE },
    { "END", lex::END },
    { "ERRLVL", lex::ERRLVL },
    { "ESCAPE", lex::ESCAPE },
    { "EXCEPT", lex::EXCEPT },
    { "EXEC", lex::EXEC },
    { "EXECUTE", lex::EXEC },
    { "EXISTS", lex::EXISTS },
    { "EXIT", lex::EXIT },
    { "EXTERNAL", lex::EXTERNAL },
    { "FETCH", lex::FETCH },
    { "FILE", lex::FILE },
    { "FILLFACTOR", lex::FILLFACTOR },
    { "FOR", lex::FOR },
    { "FOREIGN", lex::FOREIGN },
    { "FREETEXT", lex::FREETEXT },
    { "FREETEXTTABLE", lex::FREETEXTTABLE },
    { "FROM", lex::FROM },
    { "FULL", lex::FULL },
    { "FUNCTION", lex::FUNCTION },
    { "GOTO", lex::GOTO },
    { "GRANT", lex::GRANT },
    { "GROUP", lex::GROUP },
    { "HAVING", lex::HAVING },
    { "HOLDLOCK", lex::HOLDLOCK },
    { "IDENTITY", lex::IDENTITY },
    { "IDENTITY_INSERT", lex::IDENTITY_INSERT },
    { "IDENTITYCOL", lex::IDENTITYCOL },
    { "IF", lex::IF },
    { "IN", lex::SQL_IN },
    { "INDEX", lex::INDEX },
    { "INNER", lex::INNER },
    { "INSERT", lex::INSERT },
    { "INTERSECT", lex::INTERSECT },
    { "INTO", lex::INTO },
    { "IS", lex::IS },
    { "JOIN", lex::JOIN },
    { "KEY", lex::KEY },
    { "KILL", lex::KILL },
    { "LEFT", lex::LEFT },
    { "LIKE", lex::LIKE },
    { "LINENO", lex::LINENO },
    { "MERGE", lex::MERGE },
    { "NATIONAL", lex::NATIONAL },
    { "NOCHECK", lex::NOCHECK },
    { "NONCLUSTERED", lex::NONCLUSTERED },
    { "NOT", lex::NOT },
    { "NULL", lex::SQL_NULL },
    { "NULLIF", lex::NULLIF },
    { "OF", lex::OF },
    { "OFF", lex::OFF },
    { "OFFSETS", lex::OFFSETS },
    { "ON", lex::ON },
    { "OPEN", lex::OPEN },
    { "OPENDATASOURCE", lex::OPENDATASOURCE },
    { "OPENQUERY", lex::OPENQUERY },
    { "OPENROWSET", lex::OPENROWSET },
    { "OPENXML", lex::OPENXML },
    { "OPTION", lex::OPTION },
    { "OR", lex::OR },
    { "ORDER", lex::ORDER },
    { "OUTER", lex::OUTER },
    { "OVER", lex::OVER },
    { "PERCENT", lex::PERCENT },
    { "PIVOT", lex::PIVOT },
    { "PLAN", lex::PLAN },
    { "PRIMARY", lex::PRIMARY },
    { "PRINT", lex::PRINT },
    { "PROC", lex::PROCEDURE },
    { "PROCEDURE", lex::PROCEDURE },
    { "PUBLIC", lex::PUBLIC },
    { "RAISERROR", lex::RAISERROR },
    { "READ", lex::READ },
    { "READTEXT", lex::READTEXT },
    { "RECONFIGURE", lex::RECONFIGURE },
    { "REFERENCES", lex::REFERENCES },
    { "REPLICATION", lex::REPLICATION },
    { "RESTORE", lex::RESTORE },
    { "RESTRICT", lex::RESTRICT },
    { "RETURN", lex::RETURN },
    { "REVERT", lex::REVERT },
    { "REVOKE", lex::REVOKE },
    { "RIGHT", lex::RIGHT },
    { "ROLLBACK", lex::ROLLBACK },
    { "ROWCOUNT", lex::ROWCOUNT },
    { "ROWGUIDCOL", lex::ROWGUIDCOL },
    { "RULE", lex::RULE },
    { "SAVE", lex::SAVE },
    { "SCHEMA", lex::SCHEMA },
    { "SELECT", lex::SELECT },
    { "SEMANTICKEYPHRASETABLE", lex::SEMANTICKEYPHRASETABLE },
    { "SEMANTICSIMILARITYDETAILSTABLE", lex::SEMANTICSIMILARITYDETAILSTABLE },
    { "SEMANTICSIMILARITYTABLE", lex::SEMANTICSIMILARITYTABLE },
    { "SESSION_USER", lex::SESSION_USER },
    { "SET", lex::SET },
    { "SETUSER", lex::SETUSER },
    { "SHUTDOWN", lex::SHUTDOWN },
    { "SOME", lex::SOME },
    { "STATISTICS", lex::STATISTICS },
    { "SYSTEM_USER", lex::SYSTEM_USER },
    { "TABLE", lex::TABLE },
    { "TABLESAMPLE", lex::TABLESAMPLE },
    { "TEXTSIZE", lex::TEXTSIZE },
    { "THEN", lex::THEN },
    { "TO", lex::TO },
    { "TOP", lex::TOP },
    { "TRAN", lex::TRAN },
    { "TRANSACTION", lex::TRANSACTION },
    { "TRIGGER", lex::TRIGGER },
    { "TRUNCATE", lex::TRUNCATE },
    { "TRY_CONVERT", lex::TRY_CONVERT },
    { "TSEQUAL", lex::TSEQUAL },
    { "UNION", lex::UNION },
    { "UNIQUE", lex::UNIQUE },
    { "UNPIVOT", lex::UNPIVOT },
    { "UPDATE", lex::UPDATE },
    { "UPDATETEXT", lex::UPDATETEXT },
    { "USE", lex::USE },
    { "USER", lex::USER },
    { "VALUES", lex::VALUES },
    { "VARYING", lex::VARYING },
    { "VIEW", lex::VIEW },
    { "WAITFOR", lex::WAITFOR },
    { "WHEN", lex::WHEN },
    { "WHERE", lex::WHERE },
    { "WHILE", lex::WHILE },
    { "WITH", lex::WITH },
    { "WRITETEXT", lex::WRITETEXT },
};

struct word {
	word(enum lex type, std::string_view val) : type(type), val(val) { }

    enum lex type;
    std::string_view val;
};

std::list<word> parse(std::string_view s);
